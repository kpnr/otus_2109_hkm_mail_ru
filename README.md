
Отус "Архитектура и шаблоны проектирования"
============================================

Урок 3
--------

**Домашнее задание** Движение игровых объектов по полю.

**Цель:** Выработка навыка применения SOLID принципов на примере игры "Танки".

В результате выполнения ДЗ будет получен код, отвечающий за движение объектов
по игровому полю, устойчивый к появлению новых игровых объектов
и дополнительных ограничений, накладываемых на это движение.

Описание игры по [ссылке](https://docs.google.com/document/d/19QXXaUEAIMkYsZZceSCkZ8jkkryMPpqJUotwV3GGIgQ/edit?usp=sharing)

Реализовать движение объектов на игровом поле в рамках подсистемы Игровой сервер.

Урок 4
--------

Многопоточное выполнение команд.

Предположим, что у нас есть набор команд, которые необходимо выполнить.
Выполнение команд организуем в несколько потоков. Для этого будем считать,
что у каждого потока есть своя потокобезопасная очередь.
Для того, чтобы выполнить команду, ее необходимо добавить в очередь.
Поток читает очередную команду из очереди и выполняет ее.
Если выполнение команды прерывается выброшенным исключением,
 то поток должен отловить его и продолжить работу.
Если сообщений нет в очереди, то поток засыпает до тех пор, пока очередь пуста.

Урок 13
---------
Предположим, что у нас уже написаны команды MoveCommand и RotateCommand. 
Теперь возникло новое требование: пользователи в игре могут устанавливать 
правило - во время движение расходуется топливо, двигаться можно 
только при наличии топлива.

Реализовать новую возможность можно введя две новые команды.
CheckFuelCommand и BurnFuelCommand.

CheckFuelCommand проверяет, что топлива достаточно, если нет, то выбрасывает исключение CommandException.

BurnFuelCommand уменьшает количество топлива на скорость расхода топлива.

После этого мы можем три команды выстроить в цепочку.
CheckFuelCommand MoveCommand BurnFuelCommand

Чтобы это было прозрачно для пользователя реализуем Макрокоманду - специальную 
разновидность команды, которая в конструкторе  принимает массив команда,
а методе execute их все последовательно выполняет.

При повороте движущегося объекта меняется вектор мгновенной скорости.
Напишите команду, которая модифицирует вектор мгновенной скорости, в случае поворота.
Постройте цепочку команд для поворота.

1. Реализовать класс CheckFuelComamnd и тесты к нему.

2. Реализовать класс BurnFuelCommand и тесты к нему.

3. Реализовать простейшую макрокоманду и тесты к ней. Здесь простейшая - это значит,
   что при выбросе исключения вся последовательность команд приостанавливает свое
   выполнение, а макрокоманда выбрасывает CommandException.

4. Реализовать команду движения по прямой с расходом топлива, используя команды с предыдущих шагов.

5. Реализовать команду для модификации вектора мгновенной скорости при повороте.
   Необходимо учесть, что не каждый разворачивающийся объект движется.
6. Реализовать команду поворота, которая еще и меняет вектор мгновенной скорости, если есть.


# Урок 14


Реализация IoC контейнера

**Цель:** Реализовать IoC контейнер, устойчивый к изменению требований.

**В результате** выполнения домашнего задания Вы получите IoC, который можно будет
использовать в своих проектах.

В игре танки есть набор операций над игровыми объектами: движение по прямой,
поворот, выстрел. При этом содержание этих команд может отличаться для разных
игр, в зависимости от того, какие правила игры были выбраны пользователями.

Например, пользователи могут ограничить запас ход каждого танка некоторым
количеством топлива, а другой игре запретить поворачиваться танкам
по часовой стрелке и т.д.

IoC может помочь в этом случае, скрыв детали в стратегии разрешения зависимости.

Например, IoC.Resolve("двигаться прямо", obj); возвращает команду, которая чаще
всего является макрокомандой и осуществляет один шаг движения по прямой.

## Реализовать IoC контейнер, который:

1. Разрешает зависимости с помощью метода, со следующей сигнатурой:
    T IoC.Resolve(string key, params object[] args);

1. Регистрация зависимостей также происходит с помощью метода Resolve
    IoC.Resolve("IoC.Register", "aaa", (args) => new A()).Execute();

    Зависимости можно регистрировать в разных "скоупах"
    IoC.Resolve("Scopes.New", "scopeId").Execute();
    IoC.Resolve("Scopes.Current", "scopeId").Exceute();

Указание: Для работы со скоупами используйте ThreadLocal контейнер.

## Критерии оценки:

1. Интерфейс IoC устойчив к изменению требований.
    Оценка: 0 - 5 баллов (0 - совсем не устойчив,
    5 - преподаватель не смог построить ни одного контрпримера)

1. IoC предоставляет ровно один метод для всех операций. 3 балла

1. IoC предоставляет работу со скоупами для предотвращения сильной связности. 5 баллов.

1. Реализованы модульные тесты. 5 баллов

1. Реализованы многопоточные тесты. 2 балла

# Урок 16

Генерация адаптеров по интерфейсу

**Цель** В рамках данного ДЗ Вы научитесь генерировать адаптеры для интерфейсов, полученных при применении
принципа DIP. ДЗ демонстрирует применение метапрограммирования для решения рутинных задач, а также
возможности Reflection и компиляции "на лету" современных языков программирования. 

Если задание выполняется на C++, то задание заключается в написании препроцессора, который ищет
абстрактные классы и по ним генерирует код адаптера, который включается в состав проекта.
Для удобства такой препроцессор стоит запускать на этапе, предшествующем компиляции в процессе сборки,
а также стоит подумать об удалении всех сгенерированных файлов при выполнении команды clear.

Предположим, что у нас есть интерфейс
```
interface Tank.Operations.IMovable
{
  Vector getPosition();
  Vector setPosition(Vector newValue);
  Vector getVelocity();
}
```

1. Необходимо по нему сгенерировать следующий класс:
    ```
    class AutoGenerated.MovableAdapter:  Tank.Operations.IMovable
    {
      UObject obj;
      public  MovableAdapter(UObject obj)
      {
         this.obj = obj;
      }
    
      public Vector getPosition()
      {
         return IoC.Resolve("Tank.Operations.IMovable:position.get", obj);
      }
    
      public Vector getVelocity()
      {
         return IoC.Resolve("Tank.Operations.IMovable:velocity.get", obj);
      }
    
      public Vector setPosition(Vector newValue)
      {
         return IoC.Resolve("Tank.Operations.IMovable:position.set", obj, newValue);
      }
    }
    ```

    так, чтобы можно было создавать экземпляры этого класса.
    
2. Экземпляры генерируемых оберток для объекта obj можно создавать следующей строкой:
    ```
    var adapter = IoC.Resolve("Adapter", typeof(IMovable), obj);
    ```
3. Необязательная задача на подумать: если интерфейсе потребуются какие-либо методы, например, как
    ```
     interface Tank.Operations.IMovable
    {
      Vector getPosition();
      Vector setPosition(Vector newValue);
      Vector getVelocity();
    
      void finish();
    }
    ```
    Придумать реализацию адаптера для подобных методов.
    
**Критерии оценки:**
    
1. Задание сдано на проверку - 2 балла

2. Реализован генератор адаптеров - 5 баллов 

3. Реализованы тесты на генератор адаптеров - 3 балла 

4. Определена стратегия для IoC из п. 2 задания - 5 баллов 

5. Обработан случай из п. 3 задания - 5 баллов

минимальное количество баллов, которое необходимо набрать - 12 баллов

# Урок 23

Смена режимов обработки команд

**Цель:** Применить паттерн Состояние для изменения поведения обработчиков Команд.

В домашнем задании №2 была реализована многопоточная обработка очереди команд.
Предлагалось два режима остановки этой очереди - hard и soft.

Однако вариантов завершения и режимов обработки может быть  гораздо больше.
В данном домашнем задании необходимо реализовать возможность смены режима
обработки Команд в потоке, начиная со следующей Команды.

Для этого предлагается использовать паттерн Состояние. Каждое состояние будет иметь свой
режим обработки команд. Метод handle возвращает ссылку на следующее состояние.

Необходимо реализовать следующие состояния автомата:

1. "Обычное" В этом состоянии очередная команда извлекается из очереди и выполняется. 
   По умолчанию возвращается ссылка на этот же экземпляр состояния.
   Обработка команды HardStop приводит к тому, что будет возвращена "нулевая ссылка"
   на следующее состояние, что соответствует завершению работы потока.
   
   Обработка команды MoveToCommand приводит к тому, что будет возвращена ссылка
   на состояние MoveTo
2. MoveTo - состояние, в котором команды извлекаются из очереди и перенаправляются
   в другую очередь. Такое состояние может быть полезно, если хотите разгрузить
   сервер перед предстоящим его выключением.
   
   Обработка команды HardStop приводит к тому, что будет возвращена
   "нулевая ссылка" на следующее состояние, что соответствует завершению работы потока.
   
   Обработка команды RunCommand приводит к тому, что будет возвращена ссылка на
   "обычное" состояние.

**Критерии оценки:**
За выполнение каждого пункта, перечисленного ниже начисляются баллы:

1. ДЗ сдано на проверку - 2 балла
2. Код решения опубликован на github/gitlab - 1 балл
3. Настроен CI - 2 балла
4. Код компилируется без ошибок - 1 балл.
5. Написать тест, который проверяет, что после команды hard stop, поток завершается - 1 балл
6. Написать тест, который проверяет, что после команды MoveToCommand, поток переходит 
    на обработку Команд с помощью состояния MoveTo - 1 балл
7. Написать тест, который проверяет, что после команды RunCommand, поток переходит
   на обработку Команд с помощью состояния "Обычное" - 1 балл
8. Код не зависит от конкретных реализаций состояний - 1 балл

**Итого:** 10 баллов

Задание считается принятым, если набрано не менее 7 баллов.

# Урок 29

Проектная работа

Проект по созданию инфраструктуры работы с БД на Python.

У нас есть некий сервис, работающий в многопоточном режиме с запросами к
БД через Python DB API v2. Запросы выполняются в рамках соединений в
режиме не более одного соединения на поток. Для уменьшения накладных
расходов на установление и разрыв соединений с БД используется 
буфер - пул соединений.

Так же из-за неполадок в сети, сервера БД, конкуренции за разделяемые
ресурсы БД возможно возникновение множества исключительных ситуаций.
Требуется реализовать гибкую обработку, позволяющую применить несколько
стратегий восстановления после сбоя. Например, выбросить исключение
на верхний уровень, произвести переподключение (несколько переподключений)
к серверу, произвести перезапуск сбойного запроса.

Проект состоит из нескольких этапов:

1. Примитивный пул соединений - при запросе соединения берется первое
свободное соединения из пула, по окончании работы соединение возвращается
в пул. Если свободных соединений нет, то открывается новое.
2. Пул с ограниченным максимумом - аналогично примитивному, но
при достижении предела открытых соединений выбрасывается исключение
работы с БД (защита сервера БД от перегрузки).
3. Пул с автоматическим закрытием соединений при уменьшении нагрузки
на сервис. Например, по таймауту, связанному с последней активностью
соединения.
4. Прокси-соединение и, при необходимости, другие прокси-объекты,
позволяющие оценивать класс исключительной ситуации и выбирать
стратегию восстановления после ошибки.
5. Набор стратегий восстановления после ошибки, интегрирующихся и
взаимодействующих с объектами из предыдущего пункта.
6. Реализация прокси-объектов и стратегий для одного из вендоров БД.
7. Работа с вендорскими расширениями DB API v2 и, при невозможности
корректной реализации, блокировка таких расширений.
8. Обеспечение прямой совместимости проекта с будущими расширениями
DB API. Желательно с возможностью включения этих расширений в
существующую реализацию с минимумом доработок. При невозможности - 
блокировка в том или ином виде.
