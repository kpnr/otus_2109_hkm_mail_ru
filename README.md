
Отус "Архитектура и шаблоны проектирования"
============================================

Урок 3
--------

**Домашнее задание** Движение игровых объектов по полю.

**Цель:** Выработка навыка применения SOLID принципов на примере игры "Танки".

В результате выполнения ДЗ будет получен код, отвечающий за движение объектов
по игровому полю, устойчивый к появлению новых игровых объектов
и дополнительных ограничений, накладываемых на это движение.

Описание игры по [ссылке](https://docs.google.com/document/d/19QXXaUEAIMkYsZZceSCkZ8jkkryMPpqJUotwV3GGIgQ/edit?usp=sharing)

Реализовать движение объектов на игровом поле в рамках подсистемы Игровой сервер.

Урок 4
--------

Многопоточное выполнение команд.

Предположим, что у нас есть набор команд, которые необходимо выполнить.
Выполнение команд организуем в несколько потоков. Для этого будем считать,
что у каждого потока есть своя потокобезопасная очередь.
Для того чтобы выполнить команду, ее необходимо добавить в очередь.
Поток читает очередную команду из очереди и выполняет ее.
Если выполнение команды прерывается выброшенным исключением,
 то поток должен отловить его и продолжить работу.
Если сообщений нет в очереди, то поток засыпает до тех пор, пока очередь пуста.

Урок 13
---------
Предположим, что у нас уже написаны команды MoveCommand и RotateCommand. 
Теперь возникло новое требование: пользователи в игре могут устанавливать 
правило - во время движение расходуется топливо, двигаться можно 
только при наличии топлива.

Реализовать новую возможность можно введя две новые команды.
CheckFuelCommand и BurnFuelCommand.

CheckFuelCommand проверяет, что топлива достаточно, если нет, то выбрасывает исключение CommandException.

BurnFuelCommand уменьшает количество топлива на скорость расхода топлива.

После этого мы можем три команды выстроить в цепочку.
CheckFuelCommand MoveCommand BurnFuelCommand

Чтобы это было прозрачно для пользователя реализуем Макрокоманду - специальную 
разновидность команды, которая в конструкторе принимает массив команда,
а методе execute их все последовательно выполняет.

При повороте движущегося объекта меняется вектор мгновенной скорости.
Напишите команду, которая модифицирует вектор мгновенной скорости, в случае поворота.
Постройте цепочку команд для поворота.

1. Реализовать класс CheckFuelCommand и тесты к нему.

2. Реализовать класс BurnFuelCommand и тесты к нему.

3. Реализовать простейшую макрокоманду и тесты к ней. Здесь простейшая - это значит,
   что при выбросе исключения вся последовательность команд приостанавливает свое
   выполнение, а макрокоманда выбрасывает CommandException.

4. Реализовать команду движения по прямой с расходом топлива, используя команды с предыдущих шагов.

5. Реализовать команду для модификации вектора мгновенной скорости при повороте.
 Необходимо учесть, что не каждый разворачивающийся объект движется.
6. Реализовать команду поворота, которая еще и меняет вектор мгновенной скорости, если есть.


# Урок 14


Реализация IoC контейнера

**Цель:** Реализовать IoC контейнер, устойчивый к изменению требований.

**В результате** выполнения домашнего задания Вы получите IoC, который можно будет
использовать в своих проектах.

В игре танки есть набор операций над игровыми объектами: движение по прямой,
поворот, выстрел. При этом содержание этих команд может отличаться для разных
игр, в зависимости от того, какие правила игры были выбраны пользователями.

Например, пользователи могут ограничить запас ход каждого танка некоторым
количеством топлива, а другой игре запретить поворачиваться танкам
по часовой стрелке и т.д.

IoC может помочь в этом случае, скрыв детали в стратегии разрешения зависимости.

Например, `IoC.Resolve("двигаться прямо", obj);` возвращает команду, которая чаще
всего является макрокомандой и осуществляет один шаг движения по прямой.

## Реализовать IoC контейнер, который:

1. Разрешает зависимости с помощью метода, со следующей сигнатурой:
    `T IoC.Resolve(string key, params object[] args);`

1. Регистрация зависимостей также происходит с помощью метода Resolve
    `IoC.Resolve("IoC.Register", "aaa", (args) => new A()).Execute();`

    Зависимости можно регистрировать в разных "областях видимости"
    `IoC.Resolve("Scopes.New", "scopeId").Execute();`
    `IoC.Resolve("Scopes.Current", "scopeId").Exceute();`

Указание: Для работы с областями видимости используйте ThreadLocal контейнер.

## Критерии оценки:

1. Интерфейс IoC устойчив к изменению требований.
 Оценка: 0 - 5 баллов (0 - совсем не устойчив,
    5 - преподаватель не смог построить ни одного контрпримера)

1. IoC предоставляет ровно один метод для всех операций. 3 балла

1. IoC предоставляет работу с областями видимости для предотвращения сильной связности. 5 баллов.

1. Реализованы модульные тесты. 5 баллов

1. Реализованы многопоточные тесты. 2 балла

# Урок 16

Генерация адаптеров по интерфейсу

**Цель** В рамках данного ДЗ Вы научитесь генерировать адаптеры для интерфейсов, полученных при применении
принципа DIP. ДЗ демонстрирует применение метапрограммирования для решения рутинных задач, а также
возможности Reflection и компиляции "на лету" современных языков программирования. 

Если задание выполняется на C++, то задание заключается в написании препроцессора, который ищет
абстрактные классы и по ним генерирует код адаптера включаемый в состав проекта.
Для удобства такой препроцессор стоит запускать на этапе, предшествующем компиляции в процессе сборки,
а также стоит подумать об удалении всех сгенерированных файлов при выполнении команды clear.

Предположим, что у нас есть интерфейс
```
interface Tank.Operations.IMovable
{
  Vector getPosition();
  Vector setPosition(Vector newValue);
  Vector getVelocity();
}
```

1. Необходимо по нему сгенерировать следующий класс:
    ```
    class AutoGenerated.MovableAdapter:  Tank.Operations.IMovable
    {
      UObject obj;
      public  MovableAdapter(UObject obj)
      {
         this.obj = obj;
      }
    
      public Vector getPosition()
      {
         return IoC.Resolve("Tank.Operations.IMovable:position.get", obj);
      }
    
      public Vector getVelocity()
      {
         return IoC.Resolve("Tank.Operations.IMovable:velocity.get", obj);
      }
    
      public Vector setPosition(Vector newValue)
      {
         return IoC.Resolve("Tank.Operations.IMovable:position.set", obj, newValue);
      }
    }
    ```

    так, чтобы можно было создавать экземпляры этого класса.
    
2. Экземпляры генерируемых оберток для объекта obj можно создавать следующей строкой:
    ```
    var adapter = IoC.Resolve("Adapter", typeof(IMovable), obj);
    ```
3. Необязательная задача подумать: если в интерфейсе потребуются какие-либо методы, например, как
    ```
     interface Tank.Operations.IMovable
    {
      Vector getPosition();
      Vector setPosition(Vector newValue);
      Vector getVelocity();
    
      void finish();
    }
    ```
    Придумать реализацию адаптера для подобных методов.
    
**Критерии оценки:**
    
1. Задание сдано на проверку - 2 балла

2. Реализован генератор адаптеров - 5 баллов 

3. Реализованы тесты на генератор адаптеров - 3 балла 

4. Определена стратегия для IoC из п. 2 задания - 5 баллов 

5. Обработан случай из п. 3 задания - 5 баллов

Минимальное количество баллов, которое необходимо набрать - 12 баллов

# Урок 23

Смена режимов обработки команд

**Цель:** Применить паттерн Состояние для изменения поведения обработчиков Команд.

В домашнем задании №2 была реализована многопоточная обработка очереди команд.
Предлагалось два режима остановки этой очереди - hard и soft.

Однако вариантов завершения и режимов обработки может быть гораздо больше.
В данном домашнем задании необходимо реализовать возможность смены режима
обработки Команд в потоке, начиная со следующей Команды.

Для этого предлагается использовать паттерн Состояние. Каждое состояние будет иметь свой
режим обработки команд. Метод handle возвращает ссылку на следующее состояние.

Необходимо реализовать следующие состояния автомата:

1. "Обычное" В этом состоянии очередная команда извлекается из очереди и выполняется. 
   По умолчанию возвращается ссылка на этот же экземпляр состояния.
 Обработка команды HardStop приводит к тому, что будет возвращена "нулевая ссылка"
   на следующее состояние, что соответствует завершению работы потока.
   
   Обработка команды MoveToCommand приводит к тому, что будет возвращена ссылка
   на состояние MoveTo
2. MoveTo - состояние, в котором команды извлекаются из очереди и перенаправляются
   в другую очередь. Такое состояние может быть полезно, если хотите разгрузить
   сервер перед предстоящим его выключением.
   
   Обработка команды HardStop приводит к тому, что будет возвращена
   "нулевая ссылка" на следующее состояние, что соответствует завершению работы потока.
   
   Обработка команды RunCommand приводит к тому, что будет возвращена ссылка на
   "обычное" состояние.

**Критерии оценки:**
За выполнение каждого пункта, перечисленного ниже начисляются баллы:

1. ДЗ сдано на проверку - 2 балла
2. Код решения опубликован на github/gitlab - 1 балл
3. Настроен CI - 2 балла
4. Код компилируется без ошибок - 1 балл.
5. Написать тест, который проверяет, что после команды hard stop, поток завершается - 1 балл
6. Написать тест, который проверяет, что после команды MoveToCommand, поток переходит 
    на обработку Команд с помощью состояния MoveTo - 1 балл
7. Написать тест, который проверяет, что после команды RunCommand, поток переходит
   на обработку Команд с помощью состояния "Обычное" - 1 балл
8. Код не зависит от конкретных реализаций состояний - 1 балл

**Итого:** 10 баллов

Задание считается принятым, если набрано не менее 7 баллов.

# Урок 28

Инициализация игры

**Цель:** В этой ДЗ необходимо создать набор танков, расставить их на игровом поле. 

Сложность данной задачи в том, что нам заранее (до запуска приложения) неизвестно 
количество танков и их свойств. Это должно определяться пользователем при запуске
новой игры. Необходимо реализовать алгоритм, который создаст набор танков и задаст
первоначальные значения их свойств. Этот алгоритм должен оставаться неизменным при
изменении правил, по которым происходит танковое сражение.

Предлагается следующая идея для такого алгоритма:

1. Каждый этап инициализации танка будет описываться отдельной командой. На вход
   процедуре инициализации танка передается массив строк - имен команд, которые
   нужно выполнить при инициализации танка. Например, такой
   ```
       "установить принадлежность танка игроку",
       "определить положение танка на игровом поле",
       "установить направление танка",
       "установить объем топлива"
   ```
   Это возможная последовательность - зависит от выбора правил, по которым проходит сражение.
2. Сначала создается пустой объект типа `UObject`, например, вот такой строкой 
    `UObject obj = IoC.resolve("Объект");`
3. перебирая массив и именами команд для инициализации танка выполняем такой код:
    `IoC.resolve(имя команды из массива, obj).Execute(); //выполняем команду инициализации`

Пункт 2, 3 выполняем для всех танков, которые нужно расставить на игровом поле.

Реализовать стратегии IoC для:

- "установить принадлежность танка игроку", (Указание: у стратегии может быть внутренний счетчик,
    который считает, допустим, что первые три танка принадлежат первому игроку,
    а остальные - второму)
- "определить положение танка на игровом поле" в виде - расставить танки противника
    напротив друг друга на одном расстоянии.
- "установить направление танка"

**Критерии оценки:**

1. Задание сдано на проверку - 1 балл
2. Реализована процедура из пунктов 2,3 - 1балл
3. Написаны тесты на процедуру из пунктов 2,3 - 1 балл
4. Реализована стратегия и "установить принадлежность танка игроку" - 1балл
5. Реализована тесты на стратегию "установить принадлежность танка игроку" - 1балл
6. Реализована стратегия и "определить положение танка на игровом поле" - 1балл
7. Реализована тесты на стратегию "определить положение танка на игровом поле" - 1балл
8. Реализована стратегия и "установить направление танка" - 1балл
9. Реализована тесты на стратегию "установить направление танка" - 1балл

**Итого:** 9 баллов. Задание принято, если набрано 5 баллов.