"""
Релизация генератора Адаптера для заданного интерфейса
"""
import sys
from abc import abstractmethod, ABCMeta
from typing import Type, Generator
from types import new_class
from lesson3.interfaces import GenericInterface, UObject

class InterfaceToAdapterMeta(ABCMeta):
    """Метакласс для создания классов адаптеров"""

    def __new__(typ, name, bases, class_dict):
        def init(self, obj: UObject):
            self.obj = obj

        def ioc_call(module, class_name, method_name):
            def call_imp(self):
                obj = self.obj
                ioc = module.ioc
                rv = ioc.resolve(f'{class_name}:{method_name}', obj)
                return rv

            return call_imp

        if len(bases) != 1:
            raise NotImplementedError('Адаптер к множеству интерфейсов не поддерживается')
        itf = bases[0]
        if not issubclass(itf, GenericInterface):
            raise ValueError(f'Интерфейс {bases[0]!s} должен быть наследником GenericInterface')
        methods = set()
        itf_module = sys.modules[itf.__module__]
        for f_name, f_body in typ.methods_enum(itf):
            class_dict[f_name] = ioc_call(itf_module, name, f_name)
            methods.add(f_name)
        class_dict['_assert_support'] = typ.support_func(methods)
        class_dict['__init__'] = init
        rv = super().__new__(typ, name, bases, class_dict)
        return rv


    @staticmethod
    def support_func(methods: set) -> callable:
        def support_imp(cls, obj):
            for name in methods:
                if not callable(getattr(obj, name)):
                    cls._not_supported_error(cls, obj)

        return support_imp

    @staticmethod
    def methods_enum(child: Type[GenericInterface]) -> Generator:
        """Найти все методы из GenericIterface"""
        parent_list = child.__mro__
        for parent in parent_list:
            if not issubclass(parent, GenericInterface):
                continue
            for f_name, f_body in parent.__dict__.items():
                if f_name.startswith('_') or not callable(f_body):
                    continue
                yield f_name, f_body
        return


class SomeInterface(GenericInterface):
    """Проверка концепта"""
    @abstractmethod
    def method1(self, a: int, b: float) -> str:
        """Тестовый метод1"""

    @abstractmethod
    def method2(self) -> str:
        """Тестовый метод2"""


class SomeAdapter(SomeInterface, metaclass=InterfaceToAdapterMeta):
    pass

class ioc:
    @staticmethod
    def resolve(*args):
        breakpoint()
        print('\n'.join(str(x) for x in args))
        return

o = UObject(a=1, b=2)

ada = SomeAdapter(o)
ada.method2()



def interface_to_adapter(itf: Type[GenericInterface]) -> Type[GenericInterface]:
    itf_name = itf.__name__
    ada_name = f'Autogenerated_{itf_name}Adapter'
    ada_imp = new_class(ada_name, (GenericInterface,), )

